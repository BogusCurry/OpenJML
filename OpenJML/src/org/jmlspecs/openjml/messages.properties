## All keys here must start with compiler.err or compiler.warn, at least until
## we figure out how to have more than one Diagnostic generator
## Also make sure that all keys have 'jml' in them so that they can be distinguished
## from regular java error messages

### BE CAREFUL NOT TO INTRODUCE WHITE SPACE AT THE END OF MESSAGES.
### THAT WHITE SPACE IS PART OF THE ERROR MESSAGE AND CAN BE HARD TO SPOT WHEN
### ERROR MESSAGES DO NOT MATCH IN TESTS.

## Scanner errors
compiler.err.jml.bad.backslash.token=\
	This backslash token is unknown: {0}
compiler.err.jml.extraneous.backslash=\
	A backslash in a JML comment expects to be followed by a valid identifier
compiler.err.jml.unexpected.at.symbols=\
	These @ symbols are illegal here
compiler.err.jml.at.and.star.but.no.slash=\
	A sequence of @ symbols followed by a * is expected to be followed by a / to end the JML comment
compiler.err.jml.must.be.boolean=\
	An {0} statement must have a boolean argument, rather than type {1}
compiler.warn.jml.nowarn.with.no.semicolon=\
	A nowarn pragma must end with a semicolon
compiler.err.jml.bad.nowarn=\
	An illegal character found in a nowarn pragma
	
## Parser errors
compiler.err.jml.refines.missing.semicolon=\
	A refines statement needs to be ended by a semicolon
compiler.err.jml.no.args.allowed=\
	A {0} expression does not take an argument list
compiler.err.jml.args.required=\
	A {0} expression must have an argument list
compiler.err.jml.invalid.expression.or.missing.semi=\
	The expression is invalid or not terminated by a semicolon
compiler.err.jml.bad.represents.token=\
	A represents clause must have a =, <- or \\such_that after the identifier
compiler.err.jml.use.nothing.assignable=\
	Use \\nothing to denote an empty list of locations in an assignable clause
compiler.err.jml.refines.missing.string=\
	A refines declaration must contain a string literal
compiler.err.jml.refines.before.imports=\
	Refines declarations must precede all import declarations and follow any package declaration
compiler.err.jml.empty.specification.case=\
	The specification case near here is empty, which is not permitted
compiler.err.jml.bad.token.in.jml=\
	This token is not expected at this position within a JML annotation: {0}
compiler.err.jml.bad.type.expression=\
	The type or expression near here is invalid (or not implemented): {0}
compiler.err.jml.invalid.spec.group.end=\
	Invalid clause or missing end of specification group token ( |} )
compiler.err.jml.expected.decl.or.jml=\
	Expected a declaration or a JML construct inside the JML annotation here
compiler.warn.jml.misplaced.code=\
	This code token is misplaced - it must be just prior to a behavior or example token
compiler.err.jml.misplaced.var.spec=\
	This {0} clause must directly follow a field declaration
compiler.err.jml.mixed.implies=\
	==> and <== operators may not be mixed without parentheses
compiler.err.jml.bad.store.ref=\
	Incorrectly formed or terminated store-reference near here
compiler.err.jml.bad.construct=\
	Incorrectly formed or terminated {0} near here
compiler.err.jml.ident.or.star.after.dot=\
	Expected an identifier or star after the dot
compiler.err.jml.expected=\
	Expected {0}
compiler.err.jml.expected.id=\
	Expected an identifier after the dot in this context
compiler.err.jml.expected.rbracket.star=\
	Expected a right bracket after the star
compiler.err.jml.expected.rbracket=\
	Invalid expression or missing right bracket
compiler.err.jml.invalid.expression.succeeding.token=\
	An invalid expression or succeeding token near here
compiler.err.jml.naked.this.super=\
	A this or super token must be followed by a field selection
compiler.err.jml.not.after.star=\
	Further selection is not permitted after a wild-card field
compiler.err.jml.not.an.array=\
	The expression preceding the array element selection does not have array type: {0}
compiler.warn.jml.example.keyword=\
	A {1} specification case {0} appear in a for_example section
compiler.err.jml.loop.spec.misplaced=\
	Loop specifications must immediately precede a while or for statement
compiler.err.jml.invalid.type.modifier=\
	A {0} token is not valid as a type modifier	
						
## Modifier errors
compiler.err.jml.illegal.annotation=\
	This JML modifier is not allowed for a {0}
compiler.err.jml.mismatched.modifiers=\
	The type {0} in the specification matches a Java type {1} with different modifiers: {2}
compiler.err.jml.mismatched.field.modifiers=\
	The field {0} in the specification matches a Java field {1} with different modifiers: {2}
compiler.err.jml.mismatched.method.modifiers=\
	The method {0} in the specification matches a Java method {1} with different modifiers: {2}
compiler.err.jml.no.mods.allowed=\
	No modifiers are allowed prior to a {0} token
compiler.err.jml.no.java.mods.allowed=\
	No Java modifiers are allowed in a {0}
compiler.err.jml.no.mods.lightweight=\
	No modifiers are allowed prior to a lightweight specification case
compiler.err.jml.bad.mods.spec.case=\
	Only access modifiers are allowed for specification cases, not these: {0}
compiler.err.jml.bad.mods=\
	These modifiers are not allowed here: {0}
compiler.err.jml.no.nested.mode.type=\
	A model type may not contain model declarations
compiler.err.jml.no.nested.ghost.type=\
	A model type may not contain ghost declarations
compiler.err.jml.conflicting.modifiers=\
	A declaration may not be both {0} and {1}
compiler.err.jml.missing.model=\
	A method or type declaration within a JML annotation must be model
compiler.err.jml.missing.ghost.model=\
	A declaration within a JML annotation must be either ghost or model
compiler.err.jml.missing.ghost=\
	A local declaration within a JML annotation must be ghost
compiler.err.jml.ghost.model.on.java=\
	A Java declaration (not within a JML annotation) may not be either ghost or model
compiler.err.jml.ghost.on.java=\
	A Java local variable declaration (not within a JML annotation) may not be ghost
compiler.err.jml.no.code.lightweight=\
	Lightweight specifications may not be labeled as \'code\'
compiler.err.jml.represents.bad.static=\
	A represents clause and its associated model field must both be static or both not be static
compiler.err.jml.represents.expected.model=\
	The target of a represents clause must be a model field
							
## Typechecking errors
compiler.err.jml.arg.must.be.boolean=\
	The {0} side of the {1} operator should have boolean type, instead of {2}
compiler.err.jml.wrong.number.args=\
	A {0} expression expects just {1} argument, not {2}
compiler.err.jml.no.typeargs.for.fcn=\
	The JML function {0} may not have type arguments
compiler.err.jml.no.body.allowed=\
	A Java signature in a specification file may not have a body
compiler.warn.jml.did.not.attribute.specs.cuz.no.body=\
	Did not type-check the method specifications because there was no body to set an environment
compiler.err.jml.old.must.have.init=\
	A \'old\' method clause variable must have an initializer
compiler.err.jml.forall.no.init=\
	A forall method clause declaration must not have initializers
compiler.err.jml.misplaced.same=\
	A \\same token may only be used in requires clauses
compiler.err.jml.ref.arg.required=\
	The argument of {0} must be of reference type
compiler.err.jml.one.initializer.spec.only=\
	Only one initializer specification and one static_initializer specification are allowed
compiler.err.jml.non.pure.method=\
	A non-pure method is being called where it is not permitted: {0}
compiler.warn.jml.non.pure.method=\
	A non-pure method is being called where it is not permitted: {0}
compiler.err.jml.no.assign.in.pure=\
	Assignments are not allowed where pure expressions are expected
compiler.err.jml.no.incdec.in.pure=\
	Increment and decrement operators are not allowed where pure expressions are expected
compiler.err.jml.elemtype.expects.classtype=\
	The argument of \\elemtype function must have type \\TYPE (java.lang.Class), not {0}
compiler.err.jml.datagroup.must.be.model=\
	Datagroups in \"in\" and \"maps\" clauses must be model variables
compiler.err.jml.instance.in.static.datagroup=\
	A non-static variable may not be in a static datagroup
compiler.err.jml.incorrect.method.owner=\
	The method must be a direct member of the class containing the constraint clause
compiler.err.jml.no.constructors.allowed=\
	Constructors are not allowed as methods in constraint clauses
		
		
	
## Specification errors
compiler.err.jml.orphan.jml.class.decl=\
	This specification declaration of type {0} does not match any Java type declaration within type {1}
compiler.err.jml.orphan.jml.toplevel.class.decl=\
	This specification declaration of type {0} does not match any Java type declaration within compilation unit {1}
compiler.err.jml.duplicate.jml.class.decl=\
	This specification declaration of type {0} has the same name as a previous JML type declaration
compiler.err.jml.no.method.match=\
	The method {0} is a Java method (neither ghost nor model) but does not match any methods in the corresponding Java class. {1}
compiler.err.jml.no.var.match=\
	The field {0} is a Java field (neither ghost nor model) but does not match any fields in the corresponding Java class.
compiler.err.jml.duplicate.var.match=\
	This specification declaration of field {0} has the same name as a previous field declaration
compiler.err.jml.mismatched.type.parameters=\
	The specification type named {0} ({1}) with {2} type parameters matches a Java type with {3} type parameters
compiler.err.jml.mismatched.type.parameter.name=\
	The specification type named {0} ({1}) has a type parameters named {2} but the Java declaration has that type parameter named {3}
compiler.err.jml.initializer.block.allowed=\
	Initializer blocks are not allowed in specifications
compiler.err.jml.misplaced.static.represents=\
	A represents clause must be declared in the same class as the static model field it represents
compiler.err.jml.misplaced.clause=\
	{0} clauses are not permitted in {1} specification cases
compiler.err.jml.multiple.signalsonly=\
	At most one signals_only clause is permitted in a specification case
	
## Tool and environment errors
compiler.warn.jml.specs.dir.not.exist=\
	A specification path directory does not exist: {0}
compiler.err.jml.main.null.args=\
	The main entry point {0} was called with a null argument
compiler.warn.jml.no.specs=\
	The java file {0} has no specifications and is not itself on the specifications path - using it as its own specification file anyway	
compiler.err.jml.no.spec.file=\
	No specification file was found on specs path for class {0} despite it having been parsed from the source file {1}; using the source file as the specification file, but you should fix the specs path
compiler.warn.jml.bad.sp.var=\
	{0} is included in the specs path recursively or multiple times
compiler.note.jml.stop=\
	Stopping because of parsing errors
compiler.note.jml.continue=\
	Continuing bravely despite parsing errors
compiler.warn.jml.no.internal.specs=\
	Could not locate the internal specifications files - you may need to add the jmlspecs.jar explicitly on the command-line using -specs.
compiler.warn.jml.no.internal.runtime=\
	Could not locate the internal runtime classes - you may need to add the jmlruntime.jar explicitly on the command-line using -classpath.
compiler.err.jml.internal.specs.dir.not.exist=\
	The setting of openjml.eclipseSpecsProjectLocation used for testing is not correct ({0}).  It should contain the parent directory of the java4, java5, and java6 directories of the JMLspecs project; you should set it as a VM argument in run Run Configuration for tests, as in -Dopenjml.eclipseSpecsProjectLocation=...
compiler.err.jml.internal.specs.dir.not.defined=\
	The java environment variable openjml.eclipseSpecsProjectLocation used for testing must be defined.  It should contain the parent directory of the java4, java5, and java6 directories of the JMLspecs project; you should set it as a VM argument in run Run Configuration for tests, as in -Dopenjml.eclipseSpecsProjectLocation=...

## RAC errors
compiler.err.jml.duplicate.represents=\
	Duplicate represents clause - only the first is used for RAC
compiler.warn.jml.not.implemented.rac=\
	Not implemented for runtime assertion checking: {0}

## ESC errors
compiler.warn.esc.associated.decl=\
	Associated declaration
compiler.warn.esc.prover.failure=\
	Prover failed: {0}
compiler.warn.esc.unsat.preconditions=\
	Invariants+Preconditions appear to be contradictory in method {0}
compiler.warn.esc.method.invalid=\
	Method does not appear to satisfy its specifications (no counterexample information): {0}
compiler.warn.esc.assertion.invalid=\
	The prover cannot establish an assertion ({0}) in method {1}
compiler.warn.esc.infeasible.assumption=\
	An assumption appears to be infeasible in method {0}
compiler.warn.esc.infeasible.preconditions=\
	Invariants+Preconditions appear to be contradictory in method {0}
compiler.warn.esc.infeasible.branch=\
	{0} branch apparently never taken in method {1}
compiler.warn.esc.label=\
	Label {0} reported
compiler.warn.esc.label.value=\
	Label {0} has value {1}
compiler.note.esc.checking.method=\
	Checking method {0}
compiler.err.esc.proof.failed=\
	Unexpected result from prover ({0}) while checking method {1}
compiler.err.esc.internal.error=\
	INTERNAL ERROR: {0}
compiler.warn.esc.internal.error=\
	INTERNAL ERROR: {0}
compiler.warn.esc.not.implemented=\
	NOT IMPLEMENTED: {0}
compiler.err.esc.not.implemented=\
	NOT IMPLEMENTED: {0}
		
## Incomplete implementation or internal errors
compiler.err.jml.unknown.operator=\
	An unknown operator {0} is not implemented in {1}
compiler.err.jml.unknown.construct=\
	An unknown construct {0} is not implemented in {1}
compiler.err.jml.unknown.statement=\
	An unknown or not implemented JML statement type was encountered: {0}
compiler.warn.jml.unimplemented.construct=\
	The construct {0} is not yet implemented ( {1} )
compiler.err.jml.unimplemented.construct=\
	The construct {0} is not yet implemented ( {1} )
compiler.err.jml.unknown.type.token=\
	The token {0} is unknown in {1} - please report the bug	
compiler.warn.jml.internal.notsobad=\
	An internal JML error occurred, possibly recoverable.  Please report the bug with as much information as you can.\nReason: {0}
compiler.err.jml.internal.notsobad=\
	An internal JML error occurred, possibly recoverable.  Please report the bug with as much information as you can.\nReason: {0}
compiler.err.jml.internal=\
	A catastrophic JML internal error occurred.  Please report the bug with as much information as you can.\nReason: {0}
		
## UNCATEGORIZED - FIXME
compiler.err.jml.bad.secondary.type=\
	The top-level secondary type {0} in the specification file cannot be matched to a Java type
compiler.err.jml.secondary.type.not.class.name=\
	The top-level secondary type name {0} in the specification file resolves to something other than a class as a Java identifier
compiler.err.jml.toplevel.exception=\
	The compiler aborted with an uncaught exception: {0}


compiler.err.jml.expected.semicolon.quantified=\
	Expected a semicolon to separate the parts of a JML quantified expression
compiler.err.jml.max.expects.lockset=\
	A \\max function expects an argument of type {0} rather than {1}
compiler.err.jml.illformed.model.import=\
	A model import declaration must be completely within a JML comment


compiler.err.jml.mismatched.type.arguments=\
	The type {0} in the specification matches a Java type {1} with a different number of type arguments
compiler.err.jml.no.initializer.in.specs=\
	Field initializers are not permitted in specification files ({0})
compiler.err.jml.mismatched.field.types=\
	The field {0} in the specification matches a Java field {1} but they have different types: {2} vs. {3}
compiler.err.jml.mismatched.param.names=\
	Parameter {0} of method {1} has name {2} in the .java file but {3} in the specification (they should be the same)
compiler.err.jml.no.body.allowed=\
	The specification of the method {0} must not have a body
compiler.err.jml.mismatched.return.type=\
	The return types of method {0} are different in the specification and java files: {1} vs. {2}
compiler.err.jml.expected.lparen.signals=\
	Expected a left parenthesis after a signals keyword
compiler.err.jml.expected.rparen.signals=\
	Expected a right parenthesis after a signals keyword
compiler.err.jml.missing.semi=\
	Invalid expression or missing semicolon here
compiler.warn.jml.missing.semi=\
	Missing semicolon here
compiler.err.jml.use.nothing=\
	Use \\nothing to denote an empty list of exceptions in a {0} clause
compiler.err.jml.missing.comma=\
	Missing comma or otherwise ill-formed type name
compiler.err.jml.subtype.arguments=\
	The type of the arguments of the subtype operator (<:) must be either \\TYPE or java.lang.Class, not {0}

compiler.err.jml.misplaced.result=\
	A \\result expression may not be in a {0} clause
compiler.err.jml.illegal.token.for.declaration=\
	The token {0} is illegal or not implemented for a type or method clause (JmlParser.classOrInterfaceBodyDeclaration)
compiler.err.jml.misplaced.old=\
	A {0} may not be present in a {1} clause
compiler.err.jml.bad.label=\
	The second argument of an \\old expression must be a simple identifier that is a label
compiler.err.jml.void.result=\
	A \\result expression may not be used in the specification of a method that returns void
compiler.err.jml.misplaced.method.specs=\
	These method specifications in type {0} do not immediately precede a method declaration
compiler.err.jml.bad.bstype.expr=\
	More than one argument or otherwise ill-formed type expression as argument of \\type
compiler.err.jml.two.refines.clauses=\
	A compilation unit may have at most one refines clause







